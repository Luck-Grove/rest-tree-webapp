<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArcGIS Tree Mapper</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet@3.0.8/dist/esri-leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://unpkg.com/@mapbox/shp-write@0.4.3/shpwrite.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            font-size: 14px;
        }
        
        .tree-node {
            transition: all 0.3s ease;
        }
        
        .tree-node:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .floating-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            max-width: 400px;
        }

        .leaflet-popup-content {
            margin: 5px 5px;
            line-height: 1.4;
        }

        .leaflet-popup-content-wrapper {
            padding: 1px;
            text-align: left;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const ArcGISRESTTreeMap = () => {
            const [url, setUrl] = React.useState('https://sampleserver6.arcgisonline.com/arcgis/rest/services/');
            const [treeData, setTreeData] = React.useState({});
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState(null);
            const [searchTerm, setSearchTerm] = React.useState('');
            const [skipProperties, setSkipProperties] = React.useState(true);
            const [consoleMessages, setConsoleMessages] = React.useState([]);
            const [selectedPreset, setSelectedPreset] = React.useState('');
            const [expandedNodes, setExpandedNodes] = React.useState(new Set());
            const [presets, setPresets] = React.useState([]);
            const [shouldStop, setShouldStop] = React.useState(false);
            const consoleRef = React.useRef(null);
            const [filteredTreeData, setFilteredTreeData] = React.useState({});
            const [abortController, setAbortController] = React.useState(null);
            const [contextMenu, setContextMenu] = React.useState({ visible: false, x: 0, y: 0, nodeId: null });
            const [isDownloading, setIsDownloading] = React.useState(false);
            const [downloadStatus, setDownloadStatus] = React.useState('');
            const [darkMode, setDarkMode] = React.useState(true);
            const [sidebarOpen, setSidebarOpen] = React.useState(true);
            const [map, setMap] = React.useState(null);
            const [selectedLayers, setSelectedLayers] = React.useState(new Set());
            const [address, setAddress] = React.useState('');
            const [showOnlyActiveLayers, setShowOnlyActiveLayers] = React.useState(false);
            const [visibleNodes, setVisibleNodes] = React.useState(new Set());
			const [statusMessage, setStatusMessage] = React.useState('');
			const [filteredPresets, setFilteredPresets] = React.useState([]);
			const [showPresetDropdown, setShowPresetDropdown] = React.useState(false);
			const [highlightedIndex, setHighlightedIndex] = React.useState(-1);
			const presetInputRef = React.useRef(null);
			const dropdownRef = React.useRef(null);

			const [basemap, setBasemap] = React.useState('default');

			const basemaps = {
				default: {
					light: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
					dark: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
					maxNativeZoom: 19
				},
				esriAerial: {
					url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
					maxNativeZoom: 19
				},
				googleHybrid: {
					url: 'https://mt0.google.com/vt/lyrs=y&hl=en&x={x}&y={y}&z={z}',
					maxNativeZoom: 22
				}
			};

			const handleBasemapChange = (e) => {
				const selectedBasemap = e.target.value;
				setBasemap(selectedBasemap);
				
				// Save basemap choice in a cookie
				document.cookie = `basemap=${encodeURIComponent(selectedBasemap)}; path=/; max-age=31536000`; // 1 year
			};

            const [boundingBox, setBoundingBox] = React.useState(null);
            const [drawControl, setDrawControl] = React.useState(null);

			const handlePresetInputChange = (e) => {
				const input = e.target.value;
				setSelectedPreset(input);
				
				if (input.length > 0) {
					const filtered = presets.filter(preset => 
						preset.name.toLowerCase().includes(input.toLowerCase()) ||
						preset.url.toLowerCase().includes(input.toLowerCase())
					);
					setFilteredPresets(filtered);
				} else {
					setFilteredPresets(presets);
				}
				setShowPresetDropdown(true);
				setHighlightedIndex(-1);
			};

			const handlePresetSelect = (preset) => {
				setSelectedPreset(preset.name);
				setUrl(preset.url);
				setShowPresetDropdown(false);
				setHighlightedIndex(-1);
			};

			const handlePresetInputFocus = () => {
				setFilteredPresets(presets);
				setShowPresetDropdown(true);
				setHighlightedIndex(-1);
			};

			const handleKeyDown = (e) => {
				if (!showPresetDropdown) return;

				switch (e.key) {
					case 'ArrowDown':
						e.preventDefault();
						setHighlightedIndex(prevIndex => 
							prevIndex < filteredPresets.length - 1 ? prevIndex + 1 : prevIndex
						);
						break;
					case 'ArrowUp':
						e.preventDefault();
						setHighlightedIndex(prevIndex => (prevIndex > 0 ? prevIndex - 1 : 0));
						break;
					case 'Enter':
						e.preventDefault();
						if (highlightedIndex !== -1) {
							handlePresetSelect(filteredPresets[highlightedIndex]);
						}
						break;
					case 'Tab':
						if (highlightedIndex !== -1) {
							e.preventDefault();
							handlePresetSelect(filteredPresets[highlightedIndex]);
						}
						break;
					case 'Escape':
						setShowPresetDropdown(false);
						setHighlightedIndex(-1);
						break;
					default:
						break;
				}
			};

			React.useEffect(() => {
				if (highlightedIndex !== -1 && dropdownRef.current) {
					const highlightedElement = dropdownRef.current.children[highlightedIndex];
					if (highlightedElement) {
						highlightedElement.scrollIntoView({ block: 'nearest' });
					}
				}
			}, [highlightedIndex]);

			React.useEffect(() => {
				const handleClickOutside = (event) => {
					if (presetInputRef.current && !presetInputRef.current.contains(event.target)) {
						setShowPresetDropdown(false);
						setHighlightedIndex(-1);
					}
				};

				document.addEventListener('mousedown', handleClickOutside);
				return () => {
					document.removeEventListener('mousedown', handleClickOutside);
				};
			}, []);

            React.useEffect(() => {
                // Load map position and zoom from cookie
                const mapState = getCookie('mapState');
                let initialView = [0, 0];
                let initialZoom = 2;

                if (mapState) {
                    const { lat, lng, zoom } = JSON.parse(mapState);
                    initialView = [lat, lng];
                    initialZoom = zoom;
                }

                const mapInstance = L.map('map', {
                    center: initialView,
                    zoom: initialZoom,
                    zoomControl: false,
					zoomSnap: 0.1,
					zoomDelta: 0.5,
					maxZoom: 23,
					wheelPxPerZoomLevel: 100
                });
                L.control.zoom({ position: 'topright' }).addTo(mapInstance);
                setMap(mapInstance);

                return () => {
                    mapInstance.remove();
                };
            }, []);

            React.useEffect(() => {
                if (map) {
                    // Add event listener to save map state
                    const saveMapState = () => {
                        const center = map.getCenter();
                        const zoom = map.getZoom();
                        const mapState = JSON.stringify({
                            lat: center.lat,
                            lng: center.lng,
                            zoom: zoom
                        });
                        setCookie('mapState', mapState, 365); // Save for 1 year
                    };

                    map.on('moveend', saveMapState);

                    // Clean up event listener
                    return () => {
                        map.off('moveend', saveMapState);
                    };
                }
            }, [map]);

            const setCookie = (name, value, days) => {
                const expires = new Date(Date.now() + days * 864e5).toUTCString();
                document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
            };

            const getCookie = (name) => {
                return document.cookie.split('; ').reduce((r, v) => {
                    const parts = v.split('=');
                    return parts[0] === name ? decodeURIComponent(parts[1]) : r;
                }, '');
            };

			React.useEffect(() => {
				if (map) {
					map.eachLayer(layer => {
						if (layer instanceof L.TileLayer) {
							map.removeLayer(layer);
						}
					});

					let tileUrl = basemap === 'default'
						? (darkMode ? basemaps.default.dark : basemaps.default.light)
						: basemaps[basemap].url;

					let maxNativeZoom = basemap === 'default'
						? basemaps.default.maxNativeZoom
						: basemaps[basemap].maxNativeZoom;

					L.tileLayer(tileUrl, {
						attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
						maxZoom: 23,
						maxNativeZoom: maxNativeZoom
					}).addTo(map);

					// Add draw control for bounding box
					const drawControlInstance = new L.Control.Draw({
						position: 'topright',
						draw: {
							polyline: false,
							polygon: false,
							circle: false,
							marker: false,
							circlemarker: false,
							rectangle: {
								shapeOptions: {
									color: '#3388ff'
								}
							}
						},
						edit: {
							featureGroup: new L.FeatureGroup(),
							remove: true
						}
					});
					map.addControl(drawControlInstance);
					setDrawControl(drawControlInstance);

					// Event listener for draw:created
					map.on(L.Draw.Event.CREATED, (e) => {
						if (e.layerType === 'rectangle') {
							if (boundingBox) {
								map.removeLayer(boundingBox);
							}
							map.addLayer(e.layer);
							setBoundingBox(e.layer);
						}
					});

					return () => {
						map.removeControl(drawControlInstance);
					};
				}
			}, [map, darkMode, basemap]);

			React.useEffect(() => {
				const lastBasemap = document.cookie.split('; ').find(row => row.startsWith('basemap='));
				if (lastBasemap) {
					const value = lastBasemap.split('=')[1];
					setBasemap(decodeURIComponent(value));
				}
			}, []);

			React.useEffect(() => {
				if (map) {
					map.eachLayer(layer => {
						if (layer instanceof L.esri.FeatureLayer) {
							map.removeLayer(layer);
						}
					});

					selectedLayers.forEach(layerId => {
						const layer = treeData[layerId];
						if (layer && layer.url) {
							const featureLayer = L.esri.featureLayer({
								url: layer.url
							}).addTo(map);

							featureLayer.on('click', function(e) {
								const popupContent = '<div class="custom-popup ' + (darkMode ? 'dark' : 'light') + '">' + 
									Object.entries(e.layer.feature.properties)
										.map(([key, value]) => `<strong>${key}:</strong> ${value}`)
										.join('<br>') + 
									'</div>';

								L.popup({
									offset: L.point(0, -5),
									maxHeight: 300,
									maxWidth: 300,
									className: darkMode ? 'dark-popup' : 'light-popup',
									autoPan: false
								})
									.setLatLng(e.latlng)
									.setContent(popupContent)
									.openOn(map);
							});
						}
					});
				}
			}, [selectedLayers, map, darkMode, treeData]);

			React.useEffect(() => {
				setFilteredTreeData(treeData);
			}, [treeData]);

			React.useEffect(() => {
				fetchXMLPresets();
			}, []);

			React.useEffect(() => {
				if (consoleRef.current) {
					consoleRef.current.scrollTop = consoleRef.current.scrollHeight;
				}
			}, [consoleMessages]);

			React.useEffect(() => {
				const handleResize = () => {
					setSidebarOpen(window.innerWidth > 768);
				};
				window.addEventListener('resize', handleResize);
				return () => window.removeEventListener('resize', handleResize);
			}, []);

			const fetchXMLPresets = async () => {
				try {
					const response = await fetch('ArcGIS Server List.xml');
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					const xmlText = await response.text();
					const parser = new DOMParser();
					const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
					
					const connections = xmlDoc.getElementsByTagName('arcgisfeatureserver');
					const newPresets = Array.from(connections).map(connection => ({
						name: connection.getAttribute('name'),
						url: connection.getAttribute('url')
					}));
					
					setPresets(newPresets);
				} catch (error) {
					setError('Error loading XML presets: ' + error.message);
					addConsoleMessage('Error loading XML presets: ' + error.message);
				}
			};

			const addConsoleMessage = (message) => {
				setConsoleMessages(prev => [...prev, message]);
			};

			const generateTreeMap = async () => {
				setLoading(true);
				setError(null);
				setTreeData({});
				setConsoleMessages([]);
				setExpandedNodes(new Set());
				
				const controller = new AbortController();
				setAbortController(controller);

				try {
					await fetchAndDisplayServices(url, '', controller.signal);
				} catch (err) {
					if (err.name === 'AbortError') {
						addConsoleMessage('Operation was cancelled');
					} else {
						setError(err.message);
						addConsoleMessage(`An error occurred: ${err.message}`);
					}
				} finally {
					setLoading(false);
					setAbortController(null);
				}
			};

			const fetchAndDisplayServices = async (url, parent, signal) => {
				if (signal.aborted) {
					throw new Error('Operation was cancelled');
				}
				
				addConsoleMessage(<React.Fragment>Processing content for <a href={url} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:underline">{url}</a></React.Fragment>);
				try {
					const response = await axios.get(url, { 
						params: { f: 'json' },
						signal: signal
					});
					const data = response.data;

					if (data.services) {
						for (const service of data.services) {
							if (signal.aborted) throw new Error('Operation was cancelled');
							await processService(parent, service, url, signal);
						}
					}

					if (data.layers) {
						const serviceId = parent;
						for (const layer of data.layers) {
							if (signal.aborted) throw new Error('Operation was cancelled');
							const layerId = getNextId();
							const layerText = `${layer.name} (ID: ${layer.id})`;
							const layerUrl = `${url}/${layer.id}`;
							addTreeNode(serviceId, layerText, 'layer', layerUrl, layerId);
						}
						setTreeData(prevData => ({
							...prevData,
							[parent]: { ...prevData[parent], hasChildren: true }
						}));
					}

					if (data.folders) {
						for (const folder of data.folders) {
							if (signal.aborted) throw new Error('Operation was cancelled');
							const folderId = getNextId();
							const folderUrl = new URL(folder, url).href;
							addTreeNode(parent, folder, 'folder', folderUrl, folderId);
							await fetchAndDisplayServices(folderUrl, folderId, signal);
						}
					}

                    if (!skipProperties) {
                        for (const [key, value] of Object.entries(data)) {
                            if (shouldStop) throw new Error('Operation stopped by user');
                            if (['string', 'number', 'boolean'].includes(typeof value)) {
                                const propId = getNextId();
                                const propText = `${key}: ${value}`;
                                addTreeNode(parent, propText, 'property', 'N/A', propId);
                            }
                        }
                    }
				} catch (error) {
					if (error.name === 'AbortError' || error.message === 'Operation was cancelled') {
						throw new Error('Operation was cancelled');
					}
					addConsoleMessage(`Error fetching services: ${error.message}`);
					throw error;
				}
			};

			const processService = async (parent, service, baseUrl, signal) => {
				if (signal.aborted) {
					throw new Error('Operation was cancelled');
				}

				const serviceUrl = new URL(`${service.name}/${service.type}`, baseUrl).href;
				const serviceText = `${service.name} (${service.type})`;
				const serviceId = getNextId();
				addTreeNode(parent, serviceText, service.type, serviceUrl, serviceId);
				
				if (service.type === 'MapServer' || service.type === 'FeatureServer') {
					await fetchAndDisplayServices(serviceUrl, serviceId, signal);
				}
			};

            const addTreeNode = (parent, text, type, url, id) => {
                setTreeData(prevData => ({
                    ...prevData,
                    [id]: { text, parent, type, url, hasChildren: false }
                }));
            };

            const getNextId = (() => {
                let counter = 0;
                return () => {
                    counter++;
                    return `I${counter.toString().padStart(4, '0')}`;
                };
            })();

            const toggleNode = (nodeId) => {
                setExpandedNodes(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(nodeId)) {
                        newSet.delete(nodeId);
                    } else {
                        newSet.add(nodeId);
                    }
                    return newSet;
                });
            };

            const expandAll = () => {
                const allNodes = Object.keys(treeData);
                setExpandedNodes(new Set(allNodes));
            };

            const collapseAll = () => {
                setExpandedNodes(new Set());
            };
			
			const handleContextMenu = (e, nodeId) => {
				e.preventDefault();
				const node = filteredTreeData[nodeId];
				if (node && node.type === 'layer') {
					setContextMenu({
						visible: true,
						x: e.clientX,
						y: e.clientY,
						nodeId: nodeId
					});
				}
			};

            const handleDownloadLayer = async (nodeId) => {
                setContextMenu({ visible: false, x: 0, y: 0, nodeId: null });
                const node = filteredTreeData[nodeId];
                if (!node) return;

                setIsDownloading(true);
                setStatusMessage('Initializing download...');

                try {
                    const response = await axios.get(`${node.url}?f=json`);
                    const layerInfo = response.data;

                    if (layerInfo.capabilities && layerInfo.capabilities.includes('Query')) {
                        let allFeatures = [];
                        let offset = 0;
                        const limit = 1000;
                        let hasMore = true;

                        while (hasMore) {
                            let downloadUrl = `${node.url}/query?where=1%3D1&outFields=*&f=geojson&resultOffset=${offset}&resultRecordCount=${limit}`;
                            
                            // Add bounding box filter if present
                            if (boundingBox) {
                                const bounds = boundingBox.getBounds();
                                const bboxString = `${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
                                downloadUrl += `&geometry=${encodeURIComponent(bboxString)}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&inSR=4326&outSR=4326`;
                            }

                            const geojsonResponse = await fetch(downloadUrl);
                            const geojsonData = await geojsonResponse.json();
                            
                            if (geojsonData.features && geojsonData.features.length > 0) {
                                allFeatures = allFeatures.concat(geojsonData.features);
                                offset += geojsonData.features.length;
                                hasMore = geojsonData.features.length === limit;
                            } else {
                                hasMore = false;
                            }

                            setStatusMessage(`Downloaded ${allFeatures.length} features...`);
                        }

                        if (allFeatures.length === 0) {
                            setStatusMessage('No features found within the bounding box.');
                            return;
                        }

                        const completeGeojson = {
                            type: "FeatureCollection",
                            features: allFeatures
                        };

                        const blob = new Blob([JSON.stringify(completeGeojson)], { type: 'application/json' });
                        const downloadLink = document.createElement('a');
                        downloadLink.href = URL.createObjectURL(blob);
                        downloadLink.download = `${node.text.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.geojson`;
                        
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);

                        setStatusMessage(`Download completed for ${node.text}. ${allFeatures.length} features downloaded.`);
                    } else {
                        setStatusMessage('This layer does not support direct downloads.');
                    }
                } catch (error) {
                    console.error('Error fetching layer info:', error);
                    setStatusMessage(`Error downloading layer: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        setIsDownloading(false);
                        setStatusMessage('');
                    }, 5000);
                }
            };

			const handleDownloadShapefile = async (nodeId) => {
				setContextMenu({ visible: false, x: 0, y: 0, nodeId: null });
				const node = filteredTreeData[nodeId];
				if (!node) return;

				setIsDownloading(true);
				setStatusMessage('Initializing Shapefile download...');

				try {
					const response = await axios.get(`${node.url}?f=json`);
					const layerInfo = response.data;

					if (layerInfo.capabilities && layerInfo.capabilities.includes('Query')) {
						let allFeatures = [];
						let offset = 0;
						const limit = 1000;
						let hasMore = true;

						while (hasMore) {
							let downloadUrl = `${node.url}/query?where=1%3D1&outFields=*&f=geojson&resultOffset=${offset}&resultRecordCount=${limit}`;
							
							// Add bounding box filter if present
							if (boundingBox) {
								const bounds = boundingBox.getBounds();
								const bboxString = `${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
								downloadUrl += `&geometry=${encodeURIComponent(bboxString)}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&inSR=4326&outSR=4326`;
							}

							const geojsonResponse = await fetch(downloadUrl);
							const geojsonData = await geojsonResponse.json();
							
							if (geojsonData.features && geojsonData.features.length > 0) {
								allFeatures = allFeatures.concat(geojsonData.features);
								offset += geojsonData.features.length;
								hasMore = geojsonData.features.length === limit;
							} else {
								hasMore = false;
							}

							setStatusMessage(`Downloaded ${allFeatures.length} features...`);
						}

						if (allFeatures.length === 0) {
							setStatusMessage('No features found within the bounding box.');
							return;
						}

						const geojson = {
							type: "FeatureCollection",
							features: allFeatures
						};

						// Convert GeoJSON to Shapefile
						const options = {
							types: {
								point: 'points',
								polygon: 'polygons',
								line: 'lines'
							}
						};

						if (typeof window.shpwrite !== 'undefined' && typeof window.shpwrite.zip === 'function') {
							setStatusMessage('Generating Shapefile...');
							
							try {
								const content = await window.shpwrite.zip(geojson, options);
								
								console.log('ZIP content type:', Object.prototype.toString.call(content));
								console.log('ZIP content length:', content.length);

								// Convert base64 string to ArrayBuffer
								const binaryString = window.atob(content);
								const bytes = new Uint8Array(binaryString.length);
								for (let i = 0; i < binaryString.length; i++) {
									bytes[i] = binaryString.charCodeAt(i);
								}
								const arrayBuffer = bytes.buffer;

								// Create a new JSZip instance
								const zip = new JSZip();

								// Load the content into JSZip
								await zip.loadAsync(arrayBuffer);

								// Get the name of the subfolder
								const subfolderName = Object.keys(zip.files)[0].split('/')[0];

								// Create a new ZIP with files at the root
								const newZip = new JSZip();
								for (let fileName in zip.files) {
									if (zip.files[fileName].dir) continue;
									const newFileName = fileName.replace(subfolderName + '/', '');
									const content = await zip.file(fileName).async('uint8array');
									newZip.file(newFileName, content);
								}

								// Generate the final ZIP file
								const finalZipContent = await newZip.generateAsync({type: "blob"});

								console.log('Final Blob size:', finalZipContent.size);

								const zipFileName = node.text.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.zip';
								saveAs(finalZipContent, zipFileName);
								setStatusMessage(`Shapefile download completed for ${node.text}. ${allFeatures.length} features included.`);
							} catch (zipError) {
								console.error('Error in ZIP generation:', zipError);
								throw new Error('Error generating Shapefile: ' + zipError.message);
							}
						} else {
							throw new Error('shpwrite library is not properly loaded or zip method is not available.');
						}
					} else {
						setStatusMessage('This layer does not support querying features.');
					}
				} catch (error) {
					console.error('Error in shapefile generation:', error);
					setStatusMessage(`Error downloading Shapefile: ${error.message}`);
				} finally {
					setTimeout(() => {
						setIsDownloading(false);
						setStatusMessage('');
					}, 5000);
				}
			};
			
			React.useEffect(() => {
				const handleClickOutside = (event) => {
					if (contextMenu.visible && !event.target.closest('.context-menu')) {
						setContextMenu({ visible: false, x: 0, y: 0, nodeId: null });
					}
				};

					document.addEventListener('mousedown', handleClickOutside);
					return () => {
						document.removeEventListener('mousedown', handleClickOutside);
					};
			}, [contextMenu]);

			const renderContextMenu = () => {
				if (!contextMenu.visible) return null;

				return (
					<div 
						className={`absolute ${darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border shadow-md rounded-md py-2 z-50 context-menu`}
						style={{ top: `${contextMenu.y}px`, left: `${contextMenu.x}px` }}
					>
						<button 
							className={`block w-full text-left px-4 py-2 ${darkMode ? 'text-gray-200 hover:bg-gray-700' : 'text-gray-800 hover:bg-gray-100'}`}
							onClick={() => handleDownloadLayer(contextMenu.nodeId)}
						>
							Download GeoJSON
						</button>
						<button 
							className={`block w-full text-left px-4 py-2 ${darkMode ? 'text-gray-200 hover:bg-gray-700' : 'text-gray-800 hover:bg-gray-100'}`}
							onClick={() => handleDownloadShapefile(contextMenu.nodeId)}
						>
							Download Shapefile
						</button>
					</div>
				);
			};

            const renderTree = (nodeId, level = 0) => {
                const node = filteredTreeData[nodeId];
                if (!node) return null;

                if (showOnlyActiveLayers && !selectedLayers.has(nodeId) && node.type === 'layer') {
                    return null;
                }

                const childNodes = Object.entries(filteredTreeData)
                    .filter(([_, data]) => data.parent === nodeId)
                    .map(([childId, _]) => renderTree(childId, level + 1))
                    .filter(Boolean);

                if (showOnlyActiveLayers && childNodes.length === 0 && node.type !== 'layer') {
                    return null;
                }

                const isExpanded = expandedNodes.has(nodeId) || searchTerm !== '';

				const getIcon = (type) => {
					switch (type) {
						case 'folder':
							return <svg className="w-5 h-5 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>;
						case 'layer':
							return <svg className="w-5 h-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>;
						case 'MapServer':
						case 'FeatureServer':
							return <svg className="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>;
						default:
							return <svg className="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" /></svg>;
					}
				};
					
                const hasChildren = childNodes.length > 0 || node.hasChildren;
                const isLayer = node.type === 'layer';
                const hasLayerDescendant = isLayer || childNodes.some(child => child && child.props.hasLayerDescendant);

                const handleCheckboxChange = (e) => {
                    const isChecked = e.target.checked;
                    if (isLayer) {
                        setSelectedLayers(prev => {
                            const newSet = new Set(prev);
                            if (isChecked) {
                                newSet.add(nodeId);
                            } else {
                                newSet.delete(nodeId);
                            }
                            return newSet;
                        });
                    } else {
                        // If it's a folder, toggle all descendant layers
                        const toggleDescendantLayers = (id, shouldAdd) => {
                            const node = filteredTreeData[id];
                            if (node.type === 'layer') {
                                setSelectedLayers(prev => {
                                    const newSet = new Set(prev);
                                    if (shouldAdd) {
                                        newSet.add(id);
                                    } else {
                                        newSet.delete(id);
                                    }
                                    return newSet;
                                });
                            }
                            Object.entries(filteredTreeData)
                                .filter(([_, data]) => data.parent === id)
                                .forEach(([childId, _]) => toggleDescendantLayers(childId, shouldAdd));
                        };
                        toggleDescendantLayers(nodeId, isChecked);
                    }
                };

                return (
                    <div 
                        key={nodeId} 
                        className={`ml-${level * 4} ${level === 0 ? 'mt-2' : ''} fade-in`}
                        onContextMenu={(e) => handleContextMenu(e, nodeId)}
                        onClick={() => {
                            if (node.type === 'layer' && selectedLayers.has(nodeId)) {
                                zoomToLayerExtent(nodeId);
                            }
                        }}
                    >
                        <div className="flex items-center justify-between p-1 rounded-md tree-node">
                            <div className="flex items-center">
                                {hasLayerDescendant && (
                                    <input
                                        type="checkbox"
                                        checked={isLayer ? selectedLayers.has(nodeId) : childNodes.some(child => child && selectedLayers.has(child.key))}
                                        onChange={handleCheckboxChange}
                                        className="mr-2"
                                    />
                                )}
                                {hasChildren && (
                                    <button onClick={() => toggleNode(nodeId)} className="mr-2 text-xs">
                                        {isExpanded ? '▼' : '▶'}
                                    </button>
                                )}
                                <span className="mr-2">
                                    {getIcon(node.type)}
                                </span>
                                <span className="font-medium text-sm">{node.text}</span>
                                <span className="ml-2 text-xs text-gray-500">({node.type})</span>
                            </div>
                            {node.type === 'layer' && (
                                <div className="flex items-center">
                                    {/* Download Shapefile Button */}
                                    <button 
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleDownloadShapefile(nodeId);
                                        }}
                                        className={`flex flex-col items-center p-1 ${darkMode ? 'text-gray-200 hover:text-white' : 'text-gray-600 hover:text-gray-800'}`}
                                        title="Download Shapefile"
                                    >
                                        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                            <path d="M13 7h-2V3H9v4H7l3 3 3-3z"></path>
                                            <path d="M5 13h10v2H5v-2z"></path>
                                        </svg>
                                        <span className="text-xs">SHP</span>
                                    </button>
                                </div>
                            )}
                        </div>
                        {isExpanded && childNodes}
                    </div>
                );
            };

            const isNodeVisible = (nodeId) => {
                const node = treeData[nodeId];
                if (!node) return false;
                if (node.text.toLowerCase().includes(searchTerm.toLowerCase())) return true;
                if (node.type === 'layer') return true;
                return Object.keys(treeData).some(childId => 
                    treeData[childId].parent === nodeId && isNodeVisible(childId)
                );
            };

			const rootNodes = Object.entries(filteredTreeData)
				.filter(([_, data]) => data.parent === '')
				.map(([id, _]) => renderTree(id));

            const handlePresetChange = (e) => {
                const selectedUrl = e.target.value;
                setSelectedPreset(selectedUrl);
                setUrl(selectedUrl);
            };

            const handleSearchChange = (e) => {
                const searchTerm = e.target.value.toLowerCase();
                setSearchTerm(searchTerm);
                
                if (searchTerm === '') {
                    setFilteredTreeData(treeData);
                } else {
                    const newFilteredData = {};
                    Object.entries(treeData).forEach(([id, node]) => {
                        if (node.text.toLowerCase().includes(searchTerm)) {
                            insertParentChain(id, newFilteredData);
                        }
                    });
                    setFilteredTreeData(newFilteredData);
                }
                
                // Expand all nodes when searching
                if (searchTerm !== '') {
                    expandAll();
                }
            };
			
			const insertParentChain = (id, filteredData) => {
				const node = treeData[id];
				if (!node) return;

				filteredData[id] = { ...node };

				if (node.parent) {
					insertParentChain(node.parent, filteredData);
				}
			};

			const handleStopProcessing = () => {
				if (abortController) {
					abortController.abort();
					addConsoleMessage('Stopping the process...');
				}
			};

			React.useEffect(() => {
				const savedDarkMode = getCookie('darkMode');
				if (savedDarkMode !== null) {
					setDarkMode(savedDarkMode === 'true');
				}
			}, []);

			const toggleDarkMode = () => {
				setDarkMode((prevDarkMode) => {
					const newDarkMode = !prevDarkMode;
					setCookie('darkMode', newDarkMode, 365); // Save for 1 year
					return newDarkMode;
				});
			};


			React.useEffect(() => {
                if (darkMode) {
                    document.body.classList.add('dark');
                    document.body.classList.add('bg-gray-900');
                    document.body.classList.add('text-gray-100');
                } else {
                    document.body.classList.remove('dark');
                    document.body.classList.remove('bg-gray-900');
                    document.body.classList.remove('text-gray-100');
                }
            }, [darkMode]);
			
			const exportToCSV = () => {
				const csvRows = [['Layer', 'Path']];
				
				const traverseTree = (nodeId, path = '') => {
					const node = filteredTreeData[nodeId];
					if (!node) return;

					if (node.type === 'layer') {
						csvRows.push([node.text, path]);
					}

					Object.entries(filteredTreeData)
						.filter(([_, data]) => data.parent === nodeId)
						.forEach(([childId, _]) => {
							const newPath = path ? `${path}/${node.text}` : node.text;
							traverseTree(childId, newPath);
						});
				};

				Object.keys(filteredTreeData)
					.filter(id => filteredTreeData[id].parent === '')
					.forEach(id => traverseTree(id));

				const csvContent = csvRows.map(row => row.join(',')).join('\n');
				const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
				const link = document.createElement('a');
				if (link.download !== undefined) {
					const url = URL.createObjectURL(blob);
					link.setAttribute('href', url);
					link.setAttribute('download', 'arcgis_tree_map.csv');
					link.style.visibility = 'hidden';
					document.body.appendChild(link);
					link.click();
					document.body.removeChild(link);
				}
			};
			
            React.useEffect(() => {
                if (map) {
                    map.eachLayer(layer => {
                        if (layer instanceof L.TileLayer) return; // Keep the base map
                        map.removeLayer(layer);
                    });

                    selectedLayers.forEach(layerId => {
                        const layer = treeData[layerId];
                        if (layer && layer.url) {
                            const featureLayer = L.esri.featureLayer({
                                url: layer.url
                            }).addTo(map);

                            featureLayer.on('click', function(e) {
                                const popupContent = '<div>' + 
                                    Object.entries(e.layer.feature.properties)
                                        .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                                        .join('<br>') + 
                                    '</div>';
                                
                                L.popup({offset: L.point(0, -5)})
                                    .setLatLng(e.latlng)
                                    .setContent(popupContent)
                                    .openOn(map);
                            });
                        }
                    });
                }
            }, [selectedLayers, map]);

			const handleAddressSubmit = (e) => {
				e.preventDefault();
				if (map && address) {
					fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`)
						.then(response => response.json())
						.then(data => {
							if (data && data.length > 0) {
								const { lat, lon, boundingbox } = data[0];
								if (boundingbox) {
									map.fitBounds([
										[boundingbox[0], boundingbox[2]],
										[boundingbox[1], boundingbox[3]]
									]);
								} else {
									map.setView([lat, lon], 13);
								}
							} else {
								alert('Address not found');
							}
						})
						.catch(error => {
							console.error('Error in geocoding:', error);
							alert('Error in geocoding. Please try again.');
						});
				}
			};
			
			const zoomToLayerExtent = (layerId) => {
				const layer = treeData[layerId];
				if (layer && layer.url && map) {
					L.esri.query({
						url: layer.url
					}).bounds(function(error, latLngBounds) {
						if (error) {
							console.error('Error getting layer extent:', error);
							return;
						}
						if (latLngBounds) {
							map.fitBounds(latLngBounds);
						}
					});
				}
			};

			return (
				<div className={`h-screen ${darkMode ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-800'}`}>
					<div id="map" className="h-full w-full"></div>
					
					{/* Address bar */}
					<div className="absolute top-4 left-1/3 z-[1001] w-1/3">
						<form onSubmit={handleAddressSubmit} className="flex">
							<input
								type="text"
								value={address}
								onChange={(e) => setAddress(e.target.value)}
								placeholder="Enter an address..."
								className={`flex-grow px-3 py-2 text-sm ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-white text-gray-700'} border rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
							/>
							<button type="submit" className={`px-3 py-2 ${darkMode ? 'bg-blue-600' : 'bg-blue-500'} text-white rounded-r-md`}>Go</button>
						</form>
					</div>

					{/* Basemap selector */}
					<div className="absolute bottom-4 right-4 z-[1000] bg-white dark:bg-gray-800 p-2 rounded shadow-md">
						<select 
							value={basemap} 
							onChange={handleBasemapChange}
							className={`px-2 py-1 rounded ${darkMode ? 'bg-gray-700 text-gray-200' : 'bg-white text-gray-800'}`}
						>
							<option value="default">Default OSM</option>
							<option value="esriAerial">ESRI Aerial</option>
							<option value="googleHybrid">Google Hybrid</option>
						</select>
					</div>

					{/* Side panel */}
					<div className={`floating-panel p-4 ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-800'}`}>
						<div className="flex justify-between items-center mb-4">
							<h1 className="text-xl font-bold">ArcGIS Directory Tree Mapper</h1>
							<button 
								onClick={toggleDarkMode} 
								className={`px-3 py-1 rounded-md ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'} text-sm hover:bg-opacity-80 transition duration-300 ease-in-out`}
							>
								{darkMode ? 'Light' : 'Dark'}
							</button>
						</div>
						<div className="mb-4 relative" ref={presetInputRef}>
							<label className={`block mb-2 text-sm font-semibold ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>
								Select or search for a preset:
								<input
									type="text"
									value={selectedPreset}
									onChange={handlePresetInputChange}
									onFocus={handlePresetInputFocus}
									onKeyDown={handleKeyDown}
									className={`w-full px-3 py-2 mt-1 text-sm ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-white text-gray-700'} border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
									placeholder="Type to search or select a preset..."
								/>
							</label>
							{showPresetDropdown && (
								<ul 
									ref={dropdownRef}
									className={`absolute z-10 w-full mt-1 max-h-60 overflow-auto rounded-md shadow-lg ${darkMode ? 'bg-gray-700 text-gray-200' : 'bg-white text-gray-800'}`}
								>
									{filteredPresets.map((preset, index) => (
										<li
											key={index}
											onClick={() => handlePresetSelect(preset)}
											className={`px-3 py-2 cursor-pointer ${
												index === highlightedIndex
													? (darkMode ? 'bg-gray-600' : 'bg-gray-100')
													: (darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-100')
											}`}
										>
											{preset.name}
										</li>
									))}
								</ul>
							)}
						</div>
						<div className="mb-4">
							<label className={`block mb-2 text-sm font-semibold ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>
								ArcGIS REST Services URL:
								<input
									type="text"
									value={url}
									onChange={(e) => setUrl(e.target.value)}
									className={`w-full px-3 py-2 mt-1 text-sm ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-white text-gray-700'} border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
								/>
							</label>
						</div>
						<div className="mb-4 flex items-center justify-between">
							<label className="flex items-center cursor-pointer">
								<div className="relative">
									<input
										type="checkbox"
										checked={skipProperties}
										onChange={(e) => setSkipProperties(e.target.checked)}
										className="sr-only"
									/>
									<div className={`w-8 h-5 ${darkMode ? 'bg-gray-600' : 'bg-gray-300'} rounded-full shadow-inner`}></div>
									<div className={`absolute w-3 h-3 bg-white rounded-full shadow inset-y-1 left-1 transition-transform duration-300 ease-in-out ${skipProperties ? 'transform translate-x-3' : ''}`}></div>
								</div>
								<div className={`ml-3 ${darkMode ? 'text-gray-300' : 'text-gray-700'} text-sm font-medium`}>
									Skip Layer Properties
								</div>
							</label>
						</div>
						<div className="flex space-x-2 mb-4">
							<button
								onClick={generateTreeMap}
								disabled={loading}
								className={`flex-1 ${darkMode ? 'bg-blue-600' : 'bg-blue-500'} text-white px-3 py-1 rounded-md text-sm hover:bg-opacity-90 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed`}
							>
								{loading ? 'Generating...' : 'Generate Tree Map'}
							</button>
							{loading && (
								<button
									onClick={handleStopProcessing}
									className="flex-1 bg-red-500 text-white px-3 py-1 rounded-md text-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition duration-300 ease-in-out"
								>
									Stop
								</button>
							)}
						</div>
						<div className="mb-4 flex justify-between">
							<button onClick={expandAll} className={`${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'} px-2 py-1 rounded-md text-sm hover:bg-opacity-80 focus:outline-none focus:ring-2 focus:ring-opacity-50 transition duration-300 ease-in-out`}>
								Expand All
							</button>
							<button onClick={collapseAll} className={`${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700'} px-2 py-1 rounded-md text-sm hover:bg-opacity-80 focus:outline-none focus:ring-2 focus:ring-opacity-50 transition duration-300 ease-in-out`}>
								Collapse All
							</button>
							<button onClick={exportToCSV} className="bg-green-500 text-white px-2 py-1 rounded-md text-sm hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition duration-300 ease-in-out">
								Export CSV
							</button>
						</div>
						<div className="mb-4">
							<label className={`block mb-2 text-sm font-semibold ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>
								Search:
								<input
									type="text"
									value={searchTerm}
									onChange={handleSearchChange}
									className={`w-full px-3 py-2 mt-1 text-sm ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-white text-gray-700'} border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500`}
								/>
							</label>
						</div>
						<div className="mb-4">
							<label className="flex items-center cursor-pointer">
								<input
									type="checkbox"
									checked={showOnlyActiveLayers}
									onChange={(e) => setShowOnlyActiveLayers(e.target.checked)}
									className="form-checkbox h-4 w-4 text-blue-600 transition duration-150 ease-in-out"
								/>
								<span className={`ml-2 ${darkMode ? 'text-gray-300' : 'text-gray-700'} text-sm`}>Show only active layers</span>
							</label>
						</div>
						
                        {/* Bounding box info */}
                        {boundingBox && (
                            <div className="mt-4 p-2 bg-blue-100 text-blue-800 rounded-md">
                                Bounding box set. Downloads will be filtered to this area.
                            </div>
                        )}

						{/* Unified status area for errors, tips, and download status */}
						{(error || statusMessage) && (
							<div className={`mt-4 p-3 rounded-md text-sm ${
								error ? 'bg-red-100 text-red-500' : 
								isDownloading ? 'bg-blue-100 text-blue-500' : 
								'bg-green-100 text-green-500'
							}`}>
								{error || statusMessage}
							</div>
						)}
						
						<div className={`tree-container mt-4 border p-4 rounded-md ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} overflow-auto`} style={{maxHeight: 'calc(100vh - 26rem)'}}>
							{rootNodes}
							{renderContextMenu()}
						</div>
						
						{/* Console */}
						<div ref={consoleRef} className={`mt-4 h-40 overflow-auto p-2 rounded-md ${darkMode ? 'bg-gray-700' : 'bg-gray-200'}`}>
							{consoleMessages.map((message, index) => (
								<div key={index} className="text-sm">{message}</div>
							))}
						</div>
					</div>

					<style jsx global>{`
						.floating-panel {
							position: absolute;
							top: 16px;
							left: 16px;
							width: 384px; /* Equivalent to w-96 */
							z-index: 1000;
							background-color: ${darkMode ? 'rgba(31, 41, 55, 0.9)' : 'rgba(255, 255, 255, 0.9)'};
							border-radius: 4px;
							box-shadow: 0 1px 5px rgba(0,0,0,0.65);
							max-height: calc(100vh - 32px);
							overflow-y: auto;
						}
						.leaflet-popup-content-wrapper {
							padding: 0;
						}
						.leaflet-popup-content {
							margin: 0;
							max-height: 300px;
							max-width: 300px;
							overflow: auto;
						}
						.custom-popup {
							padding: 10px;
						}
						.custom-popup.dark {
							background-color: #1f2937;
							color: #f3f4f6;
						}
						.custom-popup.light {
							background-color: #ffffff;
							color: #1f2937;
						}
						.dark-popup .leaflet-popup-content-wrapper,
						.dark-popup .leaflet-popup-tip {
							background-color: #1f2937;
							color: #f3f4f6;
						}
						.light-popup .leaflet-popup-content-wrapper,
						.light-popup .leaflet-popup-tip {
							background-color: #ffffff;
							color: #1f2937;
						}
                    `}</style>
				</div>
			);
        };

        ReactDOM.render(<ArcGISRESTTreeMap />, document.getElementById('root'));
    </script>
</body>
</html>